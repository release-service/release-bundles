---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: request-and-upload-signature
  labels:
    app.kubernetes.io/version: "2.0.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Tekton task to request and upload a simple signature.

    - This task is meant to be used in an internal pipeline that can be triggered frequently
      and is expected to complete as quickly as possible.

  params:
    - description: A docker image of operator-pipeline-images for the steps to run in.
      name: pipeline_image
      default: "quay.io/konflux-ci/release-service-utils:0cf1c7923de64484f8737c0def90b74fe866040f"
      type: string
    - description: |
        List of space separated manifest digests for the signed content, usually in the format sha256:xxx
      name: manifest_digests
      type: string
    - description: Name of the user that requested the signing, for auditing purposes
      name: requester
    - description: |
        List of space separated docker references for the signed content,
        e.g. registry.com/ns/image:v4.9 registry.com/ns/image:v4.10
      name: references
      type: string
    - default: 4096R/55A34A82 SHA-256
      description: The signing key id that the content is signed with
      name: sig_key_id
      type: string
    - default: containerisvsign
      description: The signing key name that the content is signed with
      name: sig_key_name
      type: string
    - description: Kubernetes secret name that contains the Pyxis SSL files
      name: pyxis_ssl_cert_secret_name
      type: string
    - description: The key within the Kubernetes secret that contains the Pyxis SSL cert.
      name: pyxis_ssl_cert_file_name
      type: string
    - description: The key within the Kubernetes secret that contains the Pyxis SSL key.
      name: pyxis_ssl_key_file_name
      type: string
    - description: Number of threads used to upload signatures to pyxis
      name: pyxis_threads
      type: string
      default: 5
    - default: operatorpipelines
      description: Client name to connect to umb, usually a service account name
      name: umb_client_name
      type: string
    - default: VirtualTopic.eng.robosignatory.isv.sign
      description: umb topic to listen to for responses with signed content
      name: umb_listen_topic
      type: string
    - default: VirtualTopic.eng.operatorpipelines.isv.sign
      description: umb topic to publish to for requesting signing
      name: umb_publish_topic
      type: string
    - default: umb.api.redhat.com
      description: umb host to connect to for messaging
      name: umb_url
      type: string
    - description: Kubernetes secret name that contains the umb SSL files
      name: umb_ssl_cert_secret_name
      type: string
    - description: The key within the Kubernetes secret that contains the umb SSL cert.
      name: umb_ssl_cert_file_name
      type: string
    - description: The key within the Kubernetes secret that contains the umb SSL key.
      name: umb_ssl_key_file_name
      type: string
    - default: https://pyxis.engineering.redhat.com
      description: Pyxis instance to upload the signature to.
      name: pyxis_url
      type: string
    - name: signature_data_file
      description: The file where the signing response should be placed
      default: "signing_response.json"
      type: string
  steps:
    - name: build-pubtools-sign-config
      image: "$(params.pipeline_image)"
      workingDir: "$(workspaces.data.path)"
      env:
        - name: UMB_CERT_PATH
          value: "/tmp/crt"
        - name: UMB_KEY_PATH
          value: "/tmp/key"
        - name: requester
          value: $(params.requester)
        - name: manifest_digests
          value: $(params.manifest_digests)
        - name: umb_client_name
          value: $(params.umb_client_name)
        - name: umb_listen_topic
          value: $(params.umb_listen_topic)
        - name: umb_publish_topic
          value: $(params.umb_publish_topic)
        - name: umb_url
          value: $(params.umb_url)
        - name: signature_data_file
          value: "$(params.signature_data_file)"
        - name: CA_BUNDLE
          value: /etc/pki/tls/certs/ca-bundle.crt
      script: |
        #!/usr/bin/env /bin/bash
        set -x
        cat <<EOF > /tmp/pubtools-sign-config.yaml
        msg_signer:
          messaging_brokers:
            - "${umb_url}"
          messaging_cert_key: /tmp/umb.pem
          messaging_ca_cert: ${CA_BUNDLE}
          topic_send_to: ${umb_publish_topic}
          topic_listen_to: queue://Consumer.${requester}.{task_id}.${umb_listen_topic}.{task_id}
          environment: prod
          service: ${umb_client_name}
          timeout: 7
          retries: 1
          send_retries: 2
          message_id_key: request_id
          log_level: debug
        EOF

    - name: request-signature
      image: "$(params.pipeline_image)"
      workingDir: "$(workspaces.data.path)"
      env:
        - name: umb_cert
          valueFrom:
            secretKeyRef:
              name: $(params.umb_ssl_cert_secret_name)
              key: $(params.umb_ssl_cert_file_name)
        - name: umb_key
          valueFrom:
            secretKeyRef:
              name: $(params.umb_ssl_cert_secret_name)
              key: $(params.umb_ssl_key_file_name)
        - name: manifest_digests
          value: $(params.manifest_digests)
        - name: references
          value: $(params.references)
        - name: sig_key_name
          value: "$(params.sig_key_name)"
        - name: signature_data_file
          value: "$(params.signature_data_file)"
      script: |
        #!/usr/bin/env /bin/bash
        echo "${umb_cert:?}" > /tmp/umb.pem
        echo "${umb_key:?}" >> /tmp/umb.pem
        set -x
        declare -a reference_args=()
        declare -a digest_args=()
        for reference in "${references[@]}"; do
          reference_args+=("--reference")
          reference_args+=("${reference}")
        done
        for digest in "${manifest_digests[@]}"; do
          digest_args+=("--digest")
          digest_args+=("${digest}")
        done
        pubtools-sign-msg-container-sign \
          --signing-key "${sig_key_name}" \
          --config /tmp/pubtools-sign-config.yaml "${reference_args[@]}" "${digest_args[@]}" \
          --task-id $(context.taskRun.uid) > "$(workspaces.data.path)/signing_response.json"
    - name: check-signing-response
      image: "$(params.pipeline_image)"
      workingDir: "$(workspaces.data.path)"
      env:
        - name: signature_data_file
          value: "$(params.signature_data_file)"
      script: |
        #!/usr/bin/env /bin/bash
        set -xe
        cat "$(workspaces.data.path)/signing_response.json"
        STATUS=$(cat "$(workspaces.data.path)/signing_response.json" | jq ".signer_result.status" | tr -d \")
        ERRORS=$(cat "$(workspaces.data.path)/signing_response.json" | jq ".signer_result.error_message")
        # pubtools-sign response format:
        #
        # {
        #   "signer_result": {
        #     "status": ok|error,
        #     "error_message": ""
        #   },
        #   "operation_results": [
        #     [
        #       {
        #         "i": int,
        #         "msg": {
        #           "errors": [],
        #           "manifest_digest": <digest>,
        #           "pub_task_id": <task-id-identifier>,
        #           "repo": <repository>,
        #           "request_id": <radas-request-id>,
        #           "request_received_time": <ISO-8601-date>
        #           "requested_by": <name-in-certificate>,
        #           "sig_key_id": <signing-key-id>,
        #           "sig_keyname": <signing-key-name>,
        #           "signature_type": <signiture-type>,
        #           "signed_claim": <signed-claim-data>,
        #           "signing_server_requested": <ISO-8601-date>,
        #           "signing_server_responded": <ISO-8601-date>,
        #           "signing_status": str
        #         },
        #         "msg_id": <msg-id>,
        #         "timestamp": <int-timestamp>,
        #         "topic": <response-topic>,
        #         "username": <username>
        #       },
        #       # message headers
        #       {
        #         "amq6100_originalDestination": <response-topic>,
        #         "content-type": "<content-type>,
        #         "amq6100_destination": <full-response-topic>
        #       }
        #     ],
        #   ],
        #   "operation": {
        #     "digests": [
        #       <digest>
        #     ],
        #     "references": [
        #       <container-reference>
        #     ],
        #     "signing_key": <signing-key-id>
        #     "task_id": <pub-task>
        #   },
        #   "signing_key": <signing-key-id>
        # }

        SIGNATURE_ERRORS=$(cat "$(workspaces.data.path)/signing_response.json" |\
          jq -cM ".operation_results.[]|.[0].msg.errors")
        if [ "$SIGNATURE_ERRORS" != "[]" ]; then
          echo "Signing failed with error: ${SIGNATURE_ERRORS}"
          exit 1
        fi

        SIGNATURE_DATA=$(
          cat "$(workspaces.data.path)/signing_response.json" | \
          jq -cM "[
            [.operation_results, .operation.references]|
            transpose|
            .[]|
            {reference:.[1], 
             digest:.[0][0].msg.manifest_digest,
             repository:.[0][0].msg.repo,
             signature_data:.[0][0].msg.signed_claim,
             sig_key_id: .[0][0].msg.sig_key_id}
          ]")
        if [ "${STATUS}" != "ok" ]; then
          echo "Signing failed with error: ${ERRORS}"
          exit 1
        fi
        echo "${SIGNATURE_DATA}" > "${signature_data_file}"

    - name: upload-signature
      image: "$(params.pipeline_image)"
      workingDir: "$(workspaces.data.path)"
      env:
        - name: PyxisCert
          valueFrom:
            secretKeyRef:
              name: $(params.pyxis_ssl_cert_secret_name)
              key: $(params.pyxis_ssl_cert_file_name)
        - name: PyxisKey
          valueFrom:
            secretKeyRef:
              name: $(params.pyxis_ssl_cert_secret_name)
              key: $(params.pyxis_ssl_key_file_name)
        - name: PYXIS_CERT_PATH
          value: "/tmp/pyxisCert"
        - name: PYXIS_KEY_PATH
          value: "/tmp/pyxisKey"
        - name: pyxis_url
          value: $(params.pyxis_url)
        - name: pyxis_threads
          value: "$(params.pyxis_threads)"
        - name: signature_data_file
          value: "$(params.signature_data_file)"
      script: |
        #!/usr/bin/env /bin/bash
        # This helps with Shellcheck warning
        echo "${PyxisCert:?}" > "${PYXIS_CERT_PATH}"
        echo "${PyxisKey:?}" > "${PYXIS_KEY_PATH}"
        set -x
        pubtools-pyxis-upload-signatures \
          --pyxis-server "${pyxis_url}" \
          --ssl-crtfile "${PYXIS_CERT_PATH}" \
          --ssl-keyfile "${PYXIS_KEY_PATH}" \
          --request-threads "${pyxis_threads}" \
          --signature-data @"${signature_data_file}"
  workspaces:
    - name: data
